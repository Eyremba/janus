package de.mslab.ciphers;

import static org.junit.Assert.assertTrue;

import org.junit.After;
import org.junit.Before;
import org.junit.Test;

import de.mslab.core.ByteArray;
import de.mslab.utils.Logger;

@SuppressWarnings("unused")
public class MCrypton64Test {
	
	private static RoundBasedBlockCipher cipher;
	private static Logger logger;
	
	@Before
	public void setUp() throws Exception {
		cipher = new MCrypton64();
		logger = new Logger();
	}
	
	@After
	public void tearDown() throws Exception {
		cipher = null;
		logger = null;
	}
	
	@Test
	public void testComputeRoundKeys() {
		final ByteArray key = new ByteArray(cipher.getKeySize());
		cipher.setKey(key);
		
		final ByteArray expectedExpandedKey = new ByteArray(new int[]{
			0x50,0x00,0x05,0x00,0x00,0x50,0x00,0x05,
			0x60,0x00,0x06,0x00,0x00,0x60,0x00,0x06,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0xc0,0x00,0x0c,0x00,0x00,0xc0,0x00,0x0c,
			0x70,0x00,0x07,0x00,0x00,0x70,0x00,0x07,
			0x20,0x00,0x02,0x00,0x00,0x20,0x00,0x02,
			0x80,0x00,0x08,0x00,0x00,0x80,0x00,0x08,
			0xf0,0x00,0x0f,0x00,0x00,0xf0,0x00,0x0f,
			0x10,0x00,0x01,0x00,0x00,0x10,0x00,0x01,
			0xe0,0x00,0x0e,0x00,0x00,0xe0,0x00,0x0e,
			0x30,0x00,0x03,0x00,0x00,0x30,0x00,0x03,
			0xa0,0x00,0x0a,0x00,0x00,0xa0,0x00,0x0a,
			0xb0,0x00,0x0b,0x00,0x00,0xb0,0x00,0x0b
		});
		ByteArray expectedRoundKey;
		ByteArray roundKey;
		
		for (int round = 0; round <= cipher.getNumRounds(); round++) {
			expectedRoundKey = expectedExpandedKey.splice(
				round * cipher.getStateSize(), 
				(round + 1) * cipher.getStateSize()
			);
			roundKey = cipher.getRoundKey(round);
			assertTrue(expectedRoundKey.equals(roundKey));
		}
	}

	@Test
	public void testInvertComputingRoundKeys() {
		final ByteArray key = new ByteArray(cipher.getKeySize());
		cipher.setKey(key);
		
		final ByteArray expectedExpandedKey = new ByteArray(new int[]{
			0x50,0x00,0x05,0x00,0x00,0x50,0x00,0x05,
			0x60,0x00,0x06,0x00,0x00,0x60,0x00,0x06,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0xc0,0x00,0x0c,0x00,0x00,0xc0,0x00,0x0c,
			0x70,0x00,0x07,0x00,0x00,0x70,0x00,0x07,
			0x20,0x00,0x02,0x00,0x00,0x20,0x00,0x02,
			0x80,0x00,0x08,0x00,0x00,0x80,0x00,0x08,
			0xf0,0x00,0x0f,0x00,0x00,0xf0,0x00,0x0f,
			0x10,0x00,0x01,0x00,0x00,0x10,0x00,0x01,
			0xe0,0x00,0x0e,0x00,0x00,0xe0,0x00,0x0e,
			0x30,0x00,0x03,0x00,0x00,0x30,0x00,0x03,
			0xa0,0x00,0x0a,0x00,0x00,0xa0,0x00,0x0a,
			0xb0,0x00,0x0b,0x00,0x00,0xb0,0x00,0x0b
		});
		ByteArray expandedKey;
		ByteArray roundKey = new ByteArray(cipher.getKeySize());
		
		for (int round = 0; round <= cipher.getNumRounds(); round++) {
			expandedKey = cipher.computeExpandedKey(roundKey, round);
			assertTrue(expectedExpandedKey.equals(expandedKey));
		}
	}
	
}
