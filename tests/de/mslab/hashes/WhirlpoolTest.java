package de.mslab.hashes;

import static org.junit.Assert.*;

import org.junit.AfterClass;
import org.junit.BeforeClass;
import org.junit.Test;

import de.mslab.ciphers.WhirlpoolCipher;
import de.mslab.core.ByteArray;
import de.mslab.utils.Formatter;

public class WhirlpoolTest {
	
	private static Whirlpool whirlpool;
	private static WhirlpoolCipher cipher;
	
	@BeforeClass
	public static void setUpBeforeClass() throws Exception {
		cipher = new WhirlpoolCipher();
		whirlpool = new Whirlpool();
	}
	
	@AfterClass
	public static void tearDownAfterClass() throws Exception {
		cipher = null;
		whirlpool = null;
	}
	
	@Test
	public void testApplyPadding() {
		int[] message = Formatter.stringToASCIICodes("abc");
		ByteArray paddedMessage = whirlpool.applyPadding(new ByteArray(message));
		
		int[] shouldBe = { 
			0x61, 0x62, 0x63, 0x80, 0, 0, 0, 0, 
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0, 
			0, 0, 0, 0, 0, 0, 0, 0, 
			0, 0, 0, 0, 0, 0, 0, 0, 
			0, 0, 0, 0, 0, 0, 0, 0, 
			0, 0, 0, 0, 0, 0, 0, 0, 
			0, 0, 0, 0, 0, 0, 0, 0x18
		};
		
		for (int i = 0; i < shouldBe.length; i++) {
			assertEquals(shouldBe[i], paddedMessage.get(i));
		}
	}
	
	@Test
	public void testDecryption() {
		int[] key = {  
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0
		};
		int[] ciphertext = {
			0x2F, 0x46, 0x2B, 0x24, 0xC6, 0xF4, 0x86, 0xBB, 
			0x16, 0xB6, 0x56, 0x2C, 0x73, 0xB4, 0x02, 0x0B, 
			0xF3, 0x04, 0x3E, 0x3A, 0x73, 0x1B, 0xCE, 0x72, 
			0x1A, 0xE1, 0xB3, 0x03, 0xD9, 0x7E, 0x6D, 0x4C, 
			0x71, 0x81, 0xEE, 0xBD, 0xB6, 0xC5, 0x7E, 0x27, 
			0x7D, 0x0E, 0x34, 0x95, 0x71, 0x14, 0xCB, 0xD6, 
			0xC7, 0x97, 0xFC, 0x9D, 0x95, 0xD8, 0xB5, 0x82, 
			0xD2, 0x25, 0x29, 0x20, 0x76, 0xD4, 0xEE, 0xED
		};
		int[] shouldBe = {
			0x61, 0x62, 0x63, 0x80, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0x18
		};
		
		cipher.setKey(new ByteArray(key));
		ByteArray plaintext = cipher.decrypt(new ByteArray(ciphertext));
		assertTrue(new ByteArray(shouldBe).equals(plaintext));
	}
	

	@Test
	public void testEncryption() {
		int[] key = {  
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0
		};
		int[] shouldBe = {
			0x2F, 0x46, 0x2B, 0x24, 0xC6, 0xF4, 0x86, 0xBB, 
			0x16, 0xB6, 0x56, 0x2C, 0x73, 0xB4, 0x02, 0x0B, 
			0xF3, 0x04, 0x3E, 0x3A, 0x73, 0x1B, 0xCE, 0x72, 
			0x1A, 0xE1, 0xB3, 0x03, 0xD9, 0x7E, 0x6D, 0x4C, 
			0x71, 0x81, 0xEE, 0xBD, 0xB6, 0xC5, 0x7E, 0x27, 
			0x7D, 0x0E, 0x34, 0x95, 0x71, 0x14, 0xCB, 0xD6, 
			0xC7, 0x97, 0xFC, 0x9D, 0x95, 0xD8, 0xB5, 0x82, 
			0xD2, 0x25, 0x29, 0x20, 0x76, 0xD4, 0xEE, 0xED
		};
		int[] plaintext = {
			0x61, 0x62, 0x63, 0x80, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0,
			0, 0, 0, 0, 0, 0, 0, 0x18
		};
		
		cipher.setKey(new ByteArray(key));
		ByteArray ciphertext = cipher.encrypt(new ByteArray(plaintext));
		assertTrue(new ByteArray(shouldBe).equals(ciphertext));
	}
	
	@Test
	public void testIV() {
		for (int i = 0; i < 512 / 8; i++) {
			assertEquals(0, whirlpool.getInitialValue().get(i));
		}
	}
	
	@Test
	public void testHashing() {
		int[] shouldBe = { 
			0x4E, 0x24, 0x48, 0xA4, 0xC6, 0xF4, 0x86, 0xBB, 
			0x16, 0xB6, 0x56, 0x2C, 0x73, 0xB4, 0x02, 0x0B, 
			0xF3, 0x04, 0x3E, 0x3A, 0x73, 0x1B, 0xCE, 0x72, 
			0x1A, 0xE1, 0xB3, 0x03, 0xD9, 0x7E, 0x6D, 0x4C, 
			0x71, 0x81, 0xEE, 0xBD, 0xB6, 0xC5, 0x7E, 0x27, 
			0x7D, 0x0E, 0x34, 0x95, 0x71, 0x14, 0xCB, 0xD6, 
			0xC7, 0x97, 0xFC, 0x9D, 0x95, 0xD8, 0xB5, 0x82, 
			0xD2, 0x25, 0x29, 0x20, 0x76, 0xD4, 0xEE, 0xF5
		};
		testHashing("abc", shouldBe);
	}
	
	@Test
	public void testHashDoubleBlockMessage() {
		int[] shouldBe = { 
			0x2A, 0x98, 0x7E, 0xA4, 0x0F, 0x91, 0x70, 0x61, 
			0xF5, 0xD6, 0xF0, 0xA0, 0xE4, 0x64, 0x4F, 0x48, 
			0x8A, 0x7A, 0x5A, 0x52, 0xDE, 0xEE, 0x65, 0x62, 
			0x07, 0xC5, 0x62, 0xF9, 0x88, 0xE9, 0x5C, 0x69, 
			0x16, 0xBD, 0xC8, 0x03, 0x1B, 0xC5, 0xBE, 0x1B, 
			0x7B, 0x94, 0x76, 0x39, 0xFE, 0x05, 0x0B, 0x56, 
			0x93, 0x9B, 0xAA, 0xA0, 0xAD, 0xFF, 0x9A, 0xE6, 
			0x74, 0x5B, 0x7B, 0x18, 0x1C, 0x3B, 0xE3, 0xFD
		};
		testHashing("abcdbcdecdefdefgefghfghighijhijk", shouldBe);
	}
	
	@Test
	public void testHashEmptyMessage() {
		int[] shouldBe = {
			0x19, 0xFA, 0x61, 0xD7, 0x55, 0x22, 0xA4, 0x66, 
			0x9B, 0x44, 0xE3, 0x9C, 0x1D, 0x2E, 0x17, 0x26, 
			0xC5, 0x30, 0x23, 0x21, 0x30, 0xD4, 0x07, 0xF8, 
			0x9A, 0xFE, 0xE0, 0x96, 0x49, 0x97, 0xF7, 0xA7,
			0x3E, 0x83, 0xBE, 0x69, 0x8B, 0x28, 0x8F, 0xEB, 
			0xCF, 0x88, 0xE3, 0xE0, 0x3C, 0x4F, 0x07, 0x57, 
			0xEA, 0x89, 0x64, 0xE5, 0x9B, 0x63, 0xD9, 0x37,
			0x08, 0xB1, 0x38, 0xCC, 0x42, 0xA6, 0x6E, 0xB3
		};
		testHashing("", shouldBe);
	}
	
	@Test
	public void testHashLongerMessage() {
		int[] shouldBe = {
			0xDC, 0x37, 0xE0, 0x08, 0xCF, 0x9E, 0xE6, 0x9B, 
			0xF1, 0x1F, 0x00, 0xED, 0x9A, 0xBA, 0x26, 0x90, 
			0x1D, 0xD7, 0xC2, 0x8C, 0xDE, 0xC0, 0x66, 0xCC,
			0x6A, 0xF4, 0x2E, 0x40, 0xF8, 0x2F, 0x3A, 0x1E, 
			0x08, 0xEB, 0xA2, 0x66, 0x29, 0x12, 0x9D, 0x8F, 
			0xB7, 0xCB, 0x57, 0x21, 0x1B, 0x92, 0x81, 0xA6, 
			0x55, 0x17, 0xCC, 0x87, 0x9D, 0x7B, 0x96, 0x21,
			0x42, 0xC6, 0x5F, 0x5A, 0x7A, 0xF0, 0x14, 0x67
		};
		testHashing("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789", shouldBe);
	}
	
	@Test
	public void testComputeKeySchedule() {
		ByteArray key = new ByteArray(WhirlpoolCipher.NUM_BYTES_IN_512_BIT);
		cipher.setKey(key);
		
		ByteArray actualExpandedKey = cipher.getExpandedKey();
		ByteArray testedExpandedKey;
		ByteArray keyPart;
		int from, to;
		
		for (int roundIndex = 0; roundIndex <= cipher.getNumRounds(); roundIndex++) {
			from = roundIndex * cipher.getStateSize();
			to = from + cipher.getStateSize();
			keyPart = actualExpandedKey.splice(from, to);
			testedExpandedKey = cipher.computeExpandedKey(keyPart, roundIndex);
			assertTrue(actualExpandedKey.equals(testedExpandedKey));
		}
	}
	
	private void testHashing(String input, int[] shouldBe) {
		int[] message = Formatter.stringToASCIICodes(input);
		ByteArray output = whirlpool.processMessage(new ByteArray(message));
		
		assertEquals(shouldBe.length, output.length());
		assertTrue(output.equals(shouldBe));
	}
	
}
